"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_app_data-digitalization_mockData_ts"],{

/***/ "(app-pages-browser)/./app/data-digitalization/mockData.ts":
/*!*********************************************!*\
  !*** ./app/data-digitalization/mockData.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateMockResponse: function() { return /* binding */ generateMockResponse; }\n/* harmony export */ });\n// Imported from Multilingual Copy - Data Digitalization Module - Safe Integration\nconst generateMockResponse = (documentType, file)=>{\n    // Generate unique data based on file properties\n    const fileHash = file ? \"\".concat(file.name, \"-\").concat(file.size, \"-\").concat(file.lastModified) : \"default\";\n    const uniqueId = Math.abs(hashCode(fileHash)) % 10000;\n    // Generate file-specific coordinates\n    const baseLat = 22.9876 + uniqueId % 100 / 10000;\n    const baseLng = 81.1234 + uniqueId % 100 / 10000;\n    const baseResponse = {\n        metadata: {\n            language_detected: \"English, Hindi\",\n            ocr_confidence: \"\".concat(90 + uniqueId % 10, \"%\"),\n            extraction_confidence: \"\".concat(85 + uniqueId % 15, \"%\"),\n            file_name: (file === null || file === void 0 ? void 0 : file.name) || \"unknown\",\n            file_size: (file === null || file === void 0 ? void 0 : file.size) || 0,\n            file_type: (file === null || file === void 0 ? void 0 : file.type) || \"unknown\"\n        },\n        claim: {\n            claim_type: documentType,\n            claim_id: \"FRA-\".concat(uniqueId),\n            claim_status: \"pending\",\n            claim_area_ha: \"\".concat((1.0 + uniqueId % 50 / 100).toFixed(2)),\n            survey_number: \"\".concat(100 + uniqueId % 200, \"/A\"),\n            supporting_documents_present: \"yes\"\n        },\n        claimant: {\n            names: [\n                \"Claimant-\".concat(uniqueId)\n            ],\n            guardian_name: \"Guardian-\".concat(uniqueId),\n            tribe: \"Gond (ST)\"\n        },\n        location: {\n            state: \"Madhya Pradesh\",\n            district: [\n                \"Dindori\",\n                \"Mandla\",\n                \"Balaghat\"\n            ][uniqueId % 3],\n            block: \"Block-\".concat(uniqueId % 10),\n            village_name: \"Village-\".concat(uniqueId),\n            gram_sabha: \"Village-\".concat(uniqueId, \" Gram Sabha\"),\n            lgd_code: \"\".concat(450000 + uniqueId),\n            gps_coordinates: \"\".concat(baseLat.toFixed(4), \"\\xb0 N, \").concat(baseLng.toFixed(4), \"\\xb0 E\")\n        },\n        verification: {\n            frc_remarks: \"Claimant has been cultivating land since \".concat(2000 + uniqueId % 20, \".\"),\n            sdlc_remarks: \"Pending verification of caste certificate.\",\n            dlc_remarks: \"\"\n        },\n        map_data: {\n            hand_drawn_map_present: \"yes\",\n            boundary_description: \"Bounded by river to the North, forest road to the South.\",\n            polygon_points: [\n                [\n                    baseLat,\n                    baseLng\n                ],\n                [\n                    baseLat + 0.0004,\n                    baseLng + 0.0006\n                ],\n                [\n                    baseLat - 0.0006,\n                    baseLng + 0.0016\n                ],\n                [\n                    baseLat - 0.0011,\n                    baseLng + 0.0001\n                ]\n            ],\n            confidence_polygon: [\n                \"low\",\n                \"medium\",\n                \"high\"\n            ][uniqueId % 3]\n        },\n        flags: {\n            missing_fields: uniqueId % 3 === 0 ? [\n                \"household_id\"\n            ] : [],\n            possible_errors: uniqueId % 2 === 0 ? [\n                \"Area claimed exceeds average for this region\"\n            ] : [],\n            recommended_manual_check: [\n                \"Check boundary overlap with Forest Compartment \".concat(uniqueId % 200)\n            ]\n        }\n    };\n    if (documentType === \"Community Rights (CR)\") {\n        return {\n            ...baseResponse,\n            claim: {\n                ...baseResponse.claim,\n                claim_type: \"CR\",\n                claim_area_ha: \"\".concat((40 + uniqueId % 60).toFixed(1)),\n                survey_number: \"Forest Block \".concat(uniqueId % 10)\n            },\n            claimant: {\n                names: [\n                    \"\".concat(baseResponse.location.village_name, \" FRC Committee\")\n                ],\n                guardian_name: \"\",\n                tribe: \"Gond, Baiga\"\n            },\n            map_data: {\n                ...baseResponse.map_data,\n                confidence_polygon: \"high\",\n                boundary_description: \"Traditional grazing grounds and collection area.\"\n            }\n        };\n    }\n    return baseResponse;\n};\n// Simple hash function for generating consistent IDs from file properties\nfunction hashCode(str) {\n    let hash = 0;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9kYXRhLWRpZ2l0YWxpemF0aW9uL21vY2tEYXRhLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxrRkFBa0Y7QUFFM0UsTUFBTUEsdUJBQXVCLENBQUNDLGNBQXNCQztJQUN6RCxnREFBZ0Q7SUFDaEQsTUFBTUMsV0FBV0QsT0FBTyxHQUFnQkEsT0FBYkEsS0FBS0UsSUFBSSxFQUFDLEtBQWdCRixPQUFiQSxLQUFLRyxJQUFJLEVBQUMsS0FBcUIsT0FBbEJILEtBQUtJLFlBQVksSUFBSztJQUMzRSxNQUFNQyxXQUFXQyxLQUFLQyxHQUFHLENBQUNDLFNBQVNQLGFBQWE7SUFFaEQscUNBQXFDO0lBQ3JDLE1BQU1RLFVBQVUsVUFBVSxXQUFZLE1BQU87SUFDN0MsTUFBTUMsVUFBVSxVQUFVLFdBQVksTUFBTztJQUU3QyxNQUFNQyxlQUFlO1FBQ25CQyxVQUFVO1lBQ1JDLG1CQUFtQjtZQUNuQkMsZ0JBQWdCLEdBQXdCLE9BQXJCLEtBQU1ULFdBQVcsSUFBSTtZQUN4Q1UsdUJBQXVCLEdBQXdCLE9BQXJCLEtBQU1WLFdBQVcsSUFBSTtZQUMvQ1csV0FBV2hCLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTUUsSUFBSSxLQUFJO1lBQ3pCZSxXQUFXakIsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNRyxJQUFJLEtBQUk7WUFDekJlLFdBQVdsQixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1tQixJQUFJLEtBQUk7UUFDM0I7UUFDQUMsT0FBTztZQUNMQyxZQUFZdEI7WUFDWnVCLFVBQVUsT0FBZ0IsT0FBVGpCO1lBQ2pCa0IsY0FBYztZQUNkQyxlQUFlLEdBQTRDLE9BQXpDLENBQUMsTUFBTSxXQUFZLEtBQU0sR0FBRSxFQUFHQyxPQUFPLENBQUM7WUFDeERDLGVBQWUsR0FBMEIsT0FBdkIsTUFBT3JCLFdBQVcsS0FBSztZQUN6Q3NCLDhCQUE4QjtRQUNoQztRQUNBQyxVQUFVO1lBQ1JDLE9BQU87Z0JBQUUsWUFBb0IsT0FBVHhCO2FBQVc7WUFDL0J5QixlQUFlLFlBQXFCLE9BQVR6QjtZQUMzQjBCLE9BQU87UUFDVDtRQUNBQyxVQUFVO1lBQ1JDLE9BQU87WUFDUEMsVUFBVTtnQkFBQztnQkFBVztnQkFBVTthQUFXLENBQUM3QixXQUFXLEVBQUU7WUFDekQ4QixPQUFPLFNBQXVCLE9BQWQ5QixXQUFXO1lBQzNCK0IsY0FBYyxXQUFvQixPQUFUL0I7WUFDekJnQyxZQUFZLFdBQW9CLE9BQVRoQyxVQUFTO1lBQ2hDaUMsVUFBVSxHQUFxQixPQUFsQixTQUFTakM7WUFDdEJrQyxpQkFBaUIsR0FBNkI3QixPQUExQkQsUUFBUWdCLE9BQU8sQ0FBQyxJQUFHLFlBQTBCLE9BQW5CZixRQUFRZSxPQUFPLENBQUMsSUFBRztRQUNuRTtRQUNBZSxjQUFjO1lBQ1pDLGFBQWEsNENBQW1FLE9BQXZCLE9BQVFwQyxXQUFXLElBQUk7WUFDaEZxQyxjQUFjO1lBQ2RDLGFBQWE7UUFDZjtRQUNBQyxVQUFVO1lBQ1JDLHdCQUF3QjtZQUN4QkMsc0JBQXNCO1lBQ3RCQyxnQkFBZ0I7Z0JBQ2Q7b0JBQUN0QztvQkFBU0M7aUJBQVE7Z0JBQ2xCO29CQUFDRCxVQUFVO29CQUFRQyxVQUFVO2lCQUFPO2dCQUNwQztvQkFBQ0QsVUFBVTtvQkFBUUMsVUFBVTtpQkFBTztnQkFDcEM7b0JBQUNELFVBQVU7b0JBQVFDLFVBQVU7aUJBQU87YUFDckM7WUFDRHNDLG9CQUFvQjtnQkFBQztnQkFBTztnQkFBVTthQUFPLENBQUMzQyxXQUFXLEVBQUU7UUFDN0Q7UUFDQTRDLE9BQU87WUFDTEMsZ0JBQWdCN0MsV0FBVyxNQUFNLElBQUk7Z0JBQUM7YUFBZSxHQUFHLEVBQUU7WUFDMUQ4QyxpQkFBaUI5QyxXQUFXLE1BQU0sSUFBSTtnQkFBRTthQUE4QyxHQUFHLEVBQUU7WUFDM0YrQywwQkFBMEI7Z0JBQUUsa0RBQWdFLE9BQWYvQyxXQUFXO2FBQU07UUFDaEc7SUFDRjtJQUVBLElBQUlOLGlCQUFpQix5QkFBeUI7UUFDNUMsT0FBTztZQUNMLEdBQUdZLFlBQVk7WUFDZlMsT0FBTztnQkFDTCxHQUFHVCxhQUFhUyxLQUFLO2dCQUNyQkMsWUFBWTtnQkFDWkcsZUFBZSxHQUFxQyxPQUFsQyxDQUFDLEtBQU1uQixXQUFXLEVBQUUsRUFBR29CLE9BQU8sQ0FBQztnQkFDakRDLGVBQWUsZ0JBQThCLE9BQWRyQixXQUFXO1lBQzVDO1lBQ0F1QixVQUFVO2dCQUNSQyxPQUFPO29CQUFFLEdBQXFDLE9BQW5DbEIsYUFBYXFCLFFBQVEsQ0FBQ0ksWUFBWSxFQUFDO2lCQUFnQjtnQkFDOUROLGVBQWU7Z0JBQ2ZDLE9BQU87WUFDVDtZQUNBYSxVQUFVO2dCQUNSLEdBQUdqQyxhQUFhaUMsUUFBUTtnQkFDeEJJLG9CQUFvQjtnQkFDcEJGLHNCQUFzQjtZQUN4QjtRQUNGO0lBQ0Y7SUFFQSxPQUFPbkM7QUFDVCxFQUFFO0FBRUYsMEVBQTBFO0FBQzFFLFNBQVNILFNBQVM2QyxHQUFXO0lBQzNCLElBQUlDLE9BQU87SUFDWCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsSUFBSUcsTUFBTSxFQUFFRCxJQUFLO1FBQ25DLE1BQU1FLE9BQU9KLElBQUlLLFVBQVUsQ0FBQ0g7UUFDNUJELE9BQU8sQ0FBRUEsUUFBUSxLQUFLQSxPQUFRRztRQUM5QkgsT0FBT0EsT0FBT0EsTUFBTSwyQkFBMkI7SUFDakQ7SUFDQSxPQUFPQTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9kYXRhLWRpZ2l0YWxpemF0aW9uL21vY2tEYXRhLnRzPzAzYTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0ZWQgZnJvbSBNdWx0aWxpbmd1YWwgQ29weSAtIERhdGEgRGlnaXRhbGl6YXRpb24gTW9kdWxlIC0gU2FmZSBJbnRlZ3JhdGlvblxuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVNb2NrUmVzcG9uc2UgPSAoZG9jdW1lbnRUeXBlOiBzdHJpbmcsIGZpbGU/OiBGaWxlKSA9PiB7XG4gIC8vIEdlbmVyYXRlIHVuaXF1ZSBkYXRhIGJhc2VkIG9uIGZpbGUgcHJvcGVydGllc1xuICBjb25zdCBmaWxlSGFzaCA9IGZpbGUgPyBgJHtmaWxlLm5hbWV9LSR7ZmlsZS5zaXplfS0ke2ZpbGUubGFzdE1vZGlmaWVkfWAgOiAnZGVmYXVsdCc7XG4gIGNvbnN0IHVuaXF1ZUlkID0gTWF0aC5hYnMoaGFzaENvZGUoZmlsZUhhc2gpKSAlIDEwMDAwO1xuXG4gIC8vIEdlbmVyYXRlIGZpbGUtc3BlY2lmaWMgY29vcmRpbmF0ZXNcbiAgY29uc3QgYmFzZUxhdCA9IDIyLjk4NzYgKyAodW5pcXVlSWQgJSAxMDApIC8gMTAwMDA7XG4gIGNvbnN0IGJhc2VMbmcgPSA4MS4xMjM0ICsgKHVuaXF1ZUlkICUgMTAwKSAvIDEwMDAwO1xuXG4gIGNvbnN0IGJhc2VSZXNwb25zZSA9IHtcbiAgICBtZXRhZGF0YToge1xuICAgICAgbGFuZ3VhZ2VfZGV0ZWN0ZWQ6IFwiRW5nbGlzaCwgSGluZGlcIixcbiAgICAgIG9jcl9jb25maWRlbmNlOiBgJHs5MCArICh1bmlxdWVJZCAlIDEwKX0lYCxcbiAgICAgIGV4dHJhY3Rpb25fY29uZmlkZW5jZTogYCR7ODUgKyAodW5pcXVlSWQgJSAxNSl9JWAsXG4gICAgICBmaWxlX25hbWU6IGZpbGU/Lm5hbWUgfHwgJ3Vua25vd24nLFxuICAgICAgZmlsZV9zaXplOiBmaWxlPy5zaXplIHx8IDAsXG4gICAgICBmaWxlX3R5cGU6IGZpbGU/LnR5cGUgfHwgJ3Vua25vd24nXG4gICAgfSxcbiAgICBjbGFpbToge1xuICAgICAgY2xhaW1fdHlwZTogZG9jdW1lbnRUeXBlLFxuICAgICAgY2xhaW1faWQ6IGBGUkEtJHt1bmlxdWVJZH1gLFxuICAgICAgY2xhaW1fc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgIGNsYWltX2FyZWFfaGE6IGAkeygxLjAgKyAodW5pcXVlSWQgJSA1MCkgLyAxMDApLnRvRml4ZWQoMil9YCxcbiAgICAgIHN1cnZleV9udW1iZXI6IGAkezEwMCArICh1bmlxdWVJZCAlIDIwMCl9L0FgLFxuICAgICAgc3VwcG9ydGluZ19kb2N1bWVudHNfcHJlc2VudDogXCJ5ZXNcIlxuICAgIH0sXG4gICAgY2xhaW1hbnQ6IHtcbiAgICAgIG5hbWVzOiBbYENsYWltYW50LSR7dW5pcXVlSWR9YF0sXG4gICAgICBndWFyZGlhbl9uYW1lOiBgR3VhcmRpYW4tJHt1bmlxdWVJZH1gLFxuICAgICAgdHJpYmU6IFwiR29uZCAoU1QpXCJcbiAgICB9LFxuICAgIGxvY2F0aW9uOiB7XG4gICAgICBzdGF0ZTogXCJNYWRoeWEgUHJhZGVzaFwiLFxuICAgICAgZGlzdHJpY3Q6IFtcIkRpbmRvcmlcIiwgXCJNYW5kbGFcIiwgXCJCYWxhZ2hhdFwiXVt1bmlxdWVJZCAlIDNdLFxuICAgICAgYmxvY2s6IGBCbG9jay0ke3VuaXF1ZUlkICUgMTB9YCxcbiAgICAgIHZpbGxhZ2VfbmFtZTogYFZpbGxhZ2UtJHt1bmlxdWVJZH1gLFxuICAgICAgZ3JhbV9zYWJoYTogYFZpbGxhZ2UtJHt1bmlxdWVJZH0gR3JhbSBTYWJoYWAsXG4gICAgICBsZ2RfY29kZTogYCR7NDUwMDAwICsgdW5pcXVlSWR9YCxcbiAgICAgIGdwc19jb29yZGluYXRlczogYCR7YmFzZUxhdC50b0ZpeGVkKDQpfcKwIE4sICR7YmFzZUxuZy50b0ZpeGVkKDQpfcKwIEVgXG4gICAgfSxcbiAgICB2ZXJpZmljYXRpb246IHtcbiAgICAgIGZyY19yZW1hcmtzOiBgQ2xhaW1hbnQgaGFzIGJlZW4gY3VsdGl2YXRpbmcgbGFuZCBzaW5jZSAkezIwMDAgKyAodW5pcXVlSWQgJSAyMCl9LmAsXG4gICAgICBzZGxjX3JlbWFya3M6IFwiUGVuZGluZyB2ZXJpZmljYXRpb24gb2YgY2FzdGUgY2VydGlmaWNhdGUuXCIsXG4gICAgICBkbGNfcmVtYXJrczogXCJcIlxuICAgIH0sXG4gICAgbWFwX2RhdGE6IHtcbiAgICAgIGhhbmRfZHJhd25fbWFwX3ByZXNlbnQ6IFwieWVzXCIsXG4gICAgICBib3VuZGFyeV9kZXNjcmlwdGlvbjogXCJCb3VuZGVkIGJ5IHJpdmVyIHRvIHRoZSBOb3J0aCwgZm9yZXN0IHJvYWQgdG8gdGhlIFNvdXRoLlwiLFxuICAgICAgcG9seWdvbl9wb2ludHM6IFtcbiAgICAgICAgW2Jhc2VMYXQsIGJhc2VMbmddLFxuICAgICAgICBbYmFzZUxhdCArIDAuMDAwNCwgYmFzZUxuZyArIDAuMDAwNl0sXG4gICAgICAgIFtiYXNlTGF0IC0gMC4wMDA2LCBiYXNlTG5nICsgMC4wMDE2XSxcbiAgICAgICAgW2Jhc2VMYXQgLSAwLjAwMTEsIGJhc2VMbmcgKyAwLjAwMDFdXG4gICAgICBdLFxuICAgICAgY29uZmlkZW5jZV9wb2x5Z29uOiBbXCJsb3dcIiwgXCJtZWRpdW1cIiwgXCJoaWdoXCJdW3VuaXF1ZUlkICUgM11cbiAgICB9LFxuICAgIGZsYWdzOiB7XG4gICAgICBtaXNzaW5nX2ZpZWxkczogdW5pcXVlSWQgJSAzID09PSAwID8gW1wiaG91c2Vob2xkX2lkXCJdIDogW10sXG4gICAgICBwb3NzaWJsZV9lcnJvcnM6IHVuaXF1ZUlkICUgMiA9PT0gMCA/IFtgQXJlYSBjbGFpbWVkIGV4Y2VlZHMgYXZlcmFnZSBmb3IgdGhpcyByZWdpb25gXSA6IFtdLFxuICAgICAgcmVjb21tZW5kZWRfbWFudWFsX2NoZWNrOiBbYENoZWNrIGJvdW5kYXJ5IG92ZXJsYXAgd2l0aCBGb3Jlc3QgQ29tcGFydG1lbnQgJHt1bmlxdWVJZCAlIDIwMH1gXVxuICAgIH1cbiAgfTtcblxuICBpZiAoZG9jdW1lbnRUeXBlID09PSAnQ29tbXVuaXR5IFJpZ2h0cyAoQ1IpJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5iYXNlUmVzcG9uc2UsXG4gICAgICBjbGFpbToge1xuICAgICAgICAuLi5iYXNlUmVzcG9uc2UuY2xhaW0sXG4gICAgICAgIGNsYWltX3R5cGU6ICdDUicsXG4gICAgICAgIGNsYWltX2FyZWFfaGE6IGAkeyg0MCArICh1bmlxdWVJZCAlIDYwKSkudG9GaXhlZCgxKX1gLFxuICAgICAgICBzdXJ2ZXlfbnVtYmVyOiBgRm9yZXN0IEJsb2NrICR7dW5pcXVlSWQgJSAxMH1gXG4gICAgICB9LFxuICAgICAgY2xhaW1hbnQ6IHtcbiAgICAgICAgbmFtZXM6IFtgJHtiYXNlUmVzcG9uc2UubG9jYXRpb24udmlsbGFnZV9uYW1lfSBGUkMgQ29tbWl0dGVlYF0sXG4gICAgICAgIGd1YXJkaWFuX25hbWU6IFwiXCIsXG4gICAgICAgIHRyaWJlOiBcIkdvbmQsIEJhaWdhXCJcbiAgICAgIH0sXG4gICAgICBtYXBfZGF0YToge1xuICAgICAgICAuLi5iYXNlUmVzcG9uc2UubWFwX2RhdGEsXG4gICAgICAgIGNvbmZpZGVuY2VfcG9seWdvbjogXCJoaWdoXCIsXG4gICAgICAgIGJvdW5kYXJ5X2Rlc2NyaXB0aW9uOiBcIlRyYWRpdGlvbmFsIGdyYXppbmcgZ3JvdW5kcyBhbmQgY29sbGVjdGlvbiBhcmVhLlwiXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBiYXNlUmVzcG9uc2U7XG59O1xuXG4vLyBTaW1wbGUgaGFzaCBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBjb25zaXN0ZW50IElEcyBmcm9tIGZpbGUgcHJvcGVydGllc1xuZnVuY3Rpb24gaGFzaENvZGUoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGNoYXI7XG4gICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZU1vY2tSZXNwb25zZSIsImRvY3VtZW50VHlwZSIsImZpbGUiLCJmaWxlSGFzaCIsIm5hbWUiLCJzaXplIiwibGFzdE1vZGlmaWVkIiwidW5pcXVlSWQiLCJNYXRoIiwiYWJzIiwiaGFzaENvZGUiLCJiYXNlTGF0IiwiYmFzZUxuZyIsImJhc2VSZXNwb25zZSIsIm1ldGFkYXRhIiwibGFuZ3VhZ2VfZGV0ZWN0ZWQiLCJvY3JfY29uZmlkZW5jZSIsImV4dHJhY3Rpb25fY29uZmlkZW5jZSIsImZpbGVfbmFtZSIsImZpbGVfc2l6ZSIsImZpbGVfdHlwZSIsInR5cGUiLCJjbGFpbSIsImNsYWltX3R5cGUiLCJjbGFpbV9pZCIsImNsYWltX3N0YXR1cyIsImNsYWltX2FyZWFfaGEiLCJ0b0ZpeGVkIiwic3VydmV5X251bWJlciIsInN1cHBvcnRpbmdfZG9jdW1lbnRzX3ByZXNlbnQiLCJjbGFpbWFudCIsIm5hbWVzIiwiZ3VhcmRpYW5fbmFtZSIsInRyaWJlIiwibG9jYXRpb24iLCJzdGF0ZSIsImRpc3RyaWN0IiwiYmxvY2siLCJ2aWxsYWdlX25hbWUiLCJncmFtX3NhYmhhIiwibGdkX2NvZGUiLCJncHNfY29vcmRpbmF0ZXMiLCJ2ZXJpZmljYXRpb24iLCJmcmNfcmVtYXJrcyIsInNkbGNfcmVtYXJrcyIsImRsY19yZW1hcmtzIiwibWFwX2RhdGEiLCJoYW5kX2RyYXduX21hcF9wcmVzZW50IiwiYm91bmRhcnlfZGVzY3JpcHRpb24iLCJwb2x5Z29uX3BvaW50cyIsImNvbmZpZGVuY2VfcG9seWdvbiIsImZsYWdzIiwibWlzc2luZ19maWVsZHMiLCJwb3NzaWJsZV9lcnJvcnMiLCJyZWNvbW1lbmRlZF9tYW51YWxfY2hlY2siLCJzdHIiLCJoYXNoIiwiaSIsImxlbmd0aCIsImNoYXIiLCJjaGFyQ29kZUF0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/data-digitalization/mockData.ts\n"));

/***/ })

}]);